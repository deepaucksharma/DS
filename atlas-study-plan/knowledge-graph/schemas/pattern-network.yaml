# Atlas Pattern Relationship Network
# 80 architectural patterns with composition, conflict, and evolution relationships

version: "1.0"
total_patterns: 80
last_updated: "2025-09-30"

# ============================================
# Pattern Schema Definition
# ============================================

node_schema:
  Pattern:
    properties:
      id: string              # Unique pattern ID (e.g., "PAT-CQRS-001")
      name: string            # Pattern name
      category: enum          # Category (see categories below)
      complexity: enum        # simple | moderate | complex | expert
      learning_hours: float   # Hours to master
      implementation_time: string  # Time to implement in production
      description: text       # What problem it solves
      when_to_use: text       # Use case criteria
      when_not_to_use: text   # Anti-patterns
      guarantees: list[string]  # What it provides
      trade_offs: object      # Performance, consistency, cost, complexity
      real_world_usage: int   # Percentage of companies (0-100)
      companies_using: list[string]  # Which companies use it
      atlas_diagrams: list[string]  # Related diagrams
      variants: list[string]  # Pattern variations

  Relationship:
    types:
      COMPOSES_WITH:         # Patterns that work well together
        properties:
          synergy: float      # How well they combine (0.0-1.0)
          required: boolean   # Is composition necessary?
          example_system: string  # Real-world example

      CONFLICTS_WITH:        # Mutually exclusive patterns
        properties:
          reason: string      # Why they conflict
          severity: enum      # low | medium | high | blocking

      EVOLVES_TO:           # Progression path
        properties:
          trigger: string     # What causes evolution
          complexity_increase: int  # Complexity delta (1-10)

      ALTERNATIVE_TO:        # Different approach to same problem
        properties:
          trade_off: string   # Key difference
          use_case: string    # When to choose which

      REQUIRES:             # Dependency
        properties:
          necessity: float    # How necessary (0.0-1.0)

      OPTIMIZES:            # Improvement pattern
        properties:
          metric: string      # What it optimizes
          improvement: string # Typical improvement

# ============================================
# Pattern Categories
# ============================================

categories:
  - id: DATA_MANAGEMENT
    name: "Data Management Patterns"
    description: "Consistency, partitioning, replication"
    count: 15
    complexity: moderate

  - id: COMMUNICATION
    name: "Communication Patterns"
    description: "Messaging, RPC, event-driven"
    count: 12
    complexity: moderate

  - id: RESILIENCE
    name: "Resilience Patterns"
    description: "Fault tolerance, recovery, degradation"
    count: 10
    complexity: moderate

  - id: SCALABILITY
    name: "Scalability Patterns"
    description: "Load balancing, caching, partitioning"
    count: 12
    complexity: complex

  - id: CONSISTENCY
    name: "Consistency Patterns"
    description: "Transaction management, eventual consistency"
    count: 8
    complexity: complex

  - id: OBSERVABILITY
    name: "Observability Patterns"
    description: "Monitoring, tracing, logging"
    count: 7
    complexity: simple

  - id: DEPLOYMENT
    name: "Deployment Patterns"
    description: "Release strategies, migration"
    count: 8
    complexity: moderate

  - id: SECURITY
    name: "Security Patterns"
    description: "Authentication, authorization, encryption"
    count: 8
    complexity: complex

# ============================================
# Pattern Definitions (80 Patterns)
# ============================================

patterns:
  # ============================================
  # DATA MANAGEMENT PATTERNS (15)
  # ============================================

  - id: PAT-CQRS-001
    name: "CQRS (Command Query Responsibility Segregation)"
    category: DATA_MANAGEMENT
    complexity: complex
    learning_hours: 8.0
    implementation_time: "2-4 weeks"
    description: "Separate read and write models for scalability and optimization"
    when_to_use: "Read/write workload imbalance, complex domain logic, high scalability needs"
    when_not_to_use: "Simple CRUD apps, small scale, tight consistency requirements"
    guarantees:
      - "Independent scaling of reads and writes"
      - "Optimized read models"
      - "Complex query support"
    trade_offs:
      consistency: "Eventual consistency between models"
      complexity: "Higher architectural complexity"
      latency: "Potential read lag"
      cost: "Additional infrastructure"
    real_world_usage: 35
    companies_using:
      - Netflix
      - Microsoft
      - Amazon
      - LinkedIn
    atlas_diagrams:
      - "patterns/cqrs"
      - "patterns/cqrs-event-sourcing"
      - "systems/netflix-cqrs"
    variants:
      - "CQRS with Event Sourcing"
      - "CQRS with Separate Databases"
      - "Simple CQRS (same DB, different models)"

  - id: PAT-ES-001
    name: "Event Sourcing"
    category: DATA_MANAGEMENT
    complexity: expert
    learning_hours: 12.0
    implementation_time: "4-8 weeks"
    description: "Store state changes as sequence of events"
    when_to_use: "Audit trail needed, temporal queries, complex domain events"
    when_not_to_use: "Simple state management, no audit requirements, performance-critical reads"
    guarantees:
      - "Complete audit trail"
      - "Time travel queries"
      - "Event replay capability"
      - "Natural event-driven architecture"
    trade_offs:
      consistency: "Eventual consistency common"
      complexity: "Very high complexity"
      storage: "Higher storage requirements"
      query_complexity: "Complex current state queries"
    real_world_usage: 20
    companies_using:
      - Amazon
      - Microsoft
      - Uber
    atlas_diagrams:
      - "patterns/event-sourcing"
      - "patterns/event-store"
      - "systems/uber-event-sourcing"

  - id: PAT-SAGA-001
    name: "Saga Pattern"
    category: DATA_MANAGEMENT
    complexity: complex
    learning_hours: 10.0
    implementation_time: "3-6 weeks"
    description: "Distributed transaction using compensating transactions"
    when_to_use: "Microservices, cross-service transactions, no 2PC available"
    when_not_to_use: "Monolith, simple transactions, strong consistency required"
    guarantees:
      - "Eventual consistency"
      - "Rollback via compensation"
      - "No distributed locks"
    trade_offs:
      consistency: "Eventual consistency only"
      complexity: "High complexity"
      implementation: "Complex error handling"
      visibility: "Harder to debug"
    real_world_usage: 40
    companies_using:
      - Netflix
      - Uber
      - Amazon
      - Shopify
    atlas_diagrams:
      - "patterns/saga"
      - "patterns/saga-orchestration"
      - "patterns/saga-choreography"
      - "systems/netflix-saga"
    variants:
      - "Orchestration-based Saga"
      - "Choreography-based Saga"

  - id: PAT-SHARD-001
    name: "Database Sharding"
    category: DATA_MANAGEMENT
    complexity: complex
    learning_hours: 8.0
    implementation_time: "4-12 weeks"
    description: "Horizontal partitioning of data across multiple databases"
    when_to_use: "Single DB bottleneck, >10TB data, >100K QPS"
    when_not_to_use: "Small data (<1TB), complex joins needed, early stage"
    guarantees:
      - "Horizontal scalability"
      - "Isolation of failures"
      - "Geographic distribution"
    trade_offs:
      consistency: "Cross-shard consistency hard"
      complexity: "Very high operational complexity"
      queries: "Cross-shard joins expensive"
      rebalancing: "Data migration complexity"
    real_world_usage: 60
    companies_using:
      - Instagram
      - Pinterest
      - Uber
      - Discord
      - Shopify
    atlas_diagrams:
      - "patterns/database-sharding"
      - "patterns/shard-key-design"
      - "systems/instagram-sharding"
    variants:
      - "Range-based Sharding"
      - "Hash-based Sharding"
      - "Geo-based Sharding"
      - "Directory-based Sharding"

  - id: PAT-REP-001
    name: "Read Replica Pattern"
    category: DATA_MANAGEMENT
    complexity: moderate
    learning_hours: 4.0
    implementation_time: "1-2 weeks"
    description: "Replicate data to read-only copies for query offloading"
    when_to_use: "Read-heavy workload, acceptable replication lag, reporting queries"
    when_not_to_use: "Write-heavy, strong consistency needed, low latency reads required"
    guarantees:
      - "Read scalability"
      - "Reduced leader load"
      - "Geographic distribution"
    trade_offs:
      consistency: "Replication lag (seconds to minutes)"
      complexity: "Moderate complexity"
      cost: "Additional infrastructure"
    real_world_usage: 85
    companies_using:
      - GitHub
      - Stack Overflow
      - Reddit
      - Medium
    atlas_diagrams:
      - "patterns/read-replicas"
      - "systems/github-read-replicas"

  - id: PAT-CDC-001
    name: "Change Data Capture (CDC)"
    category: DATA_MANAGEMENT
    complexity: complex
    learning_hours: 6.0
    implementation_time: "2-4 weeks"
    description: "Capture database changes as event stream"
    when_to_use: "Real-time sync, event-driven architecture, audit trail"
    when_not_to_use: "Batch updates sufficient, no downstream consumers"
    guarantees:
      - "Real-time change propagation"
      - "Ordered event stream"
      - "Minimal source impact"
    trade_offs:
      consistency: "Eventually consistent"
      complexity: "Moderate complexity"
      latency: "Near real-time (not real-time)"
    real_world_usage: 50
    companies_using:
      - LinkedIn
      - Netflix
      - Uber
      - Airbnb
    atlas_diagrams:
      - "patterns/change-data-capture"
      - "systems/linkedin-kafka-cdc"

  # ============================================
  # COMMUNICATION PATTERNS (12)
  # ============================================

  - id: PAT-ASYNC-001
    name: "Asynchronous Messaging"
    category: COMMUNICATION
    complexity: moderate
    learning_hours: 5.0
    implementation_time: "1-3 weeks"
    description: "Decouple services using message queues"
    when_to_use: "Decoupling needed, variable load, async processing"
    when_not_to_use: "Synchronous response needed, simple request-response"
    guarantees:
      - "Temporal decoupling"
      - "Load smoothing"
      - "Fault tolerance"
    trade_offs:
      latency: "Higher latency"
      complexity: "Message ordering complexity"
      debugging: "Harder to trace"
    real_world_usage: 75
    companies_using:
      - Amazon
      - Netflix
      - Uber
      - Airbnb
    atlas_diagrams:
      - "patterns/async-messaging"
      - "patterns/message-queues"
    variants:
      - "Point-to-Point Queue"
      - "Publish-Subscribe"
      - "Request-Reply"

  - id: PAT-PUBSUB-001
    name: "Publish-Subscribe"
    category: COMMUNICATION
    complexity: moderate
    learning_hours: 4.0
    implementation_time: "1-2 weeks"
    description: "One-to-many message distribution"
    when_to_use: "Multiple consumers, fan-out, event notification"
    when_not_to_use: "Single consumer, guaranteed delivery to specific target"
    guarantees:
      - "Decoupled publishers/subscribers"
      - "Dynamic subscription"
      - "Scalable fan-out"
    trade_offs:
      delivery: "At-least-once or at-most-once"
      ordering: "Per-topic ordering only"
      complexity: "Moderate"
    real_world_usage: 80
    companies_using:
      - Google
      - Netflix
      - Spotify
      - Twitter
    atlas_diagrams:
      - "patterns/pub-sub"
      - "systems/google-pubsub"
    variants:
      - "Topic-based"
      - "Content-based"

  - id: PAT-EVENT-001
    name: "Event-Driven Architecture"
    category: COMMUNICATION
    complexity: complex
    learning_hours: 10.0
    implementation_time: "4-12 weeks"
    description: "System driven by production, detection, and reaction to events"
    when_to_use: "Loosely coupled services, real-time processing, complex workflows"
    when_not_to_use: "Simple CRUD, tight coupling acceptable, strong consistency needed"
    guarantees:
      - "Loose coupling"
      - "Scalability"
      - "Real-time responsiveness"
    trade_offs:
      consistency: "Eventual consistency"
      complexity: "Very high complexity"
      debugging: "Distributed tracing essential"
      testing: "Complex integration testing"
    real_world_usage: 55
    companies_using:
      - Netflix
      - Uber
      - Amazon
      - LinkedIn
    atlas_diagrams:
      - "patterns/event-driven-architecture"
      - "systems/netflix-event-driven"
    variants:
      - "Event Notification"
      - "Event-Carried State Transfer"
      - "Event Sourcing"
      - "CQRS"

  - id: PAT-RPC-001
    name: "Remote Procedure Call (RPC)"
    category: COMMUNICATION
    complexity: simple
    learning_hours: 3.0
    implementation_time: "1 week"
    description: "Synchronous request-response between services"
    when_to_use: "Low latency needed, simple request-response, tight coupling acceptable"
    when_not_to_use: "High latency operations, fan-out, fire-and-forget"
    guarantees:
      - "Synchronous response"
      - "Type safety (gRPC)"
      - "Low overhead"
    trade_offs:
      coupling: "Tight coupling"
      availability: "Caller blocked"
      scalability: "Cascade failures"
    real_world_usage: 90
    companies_using:
      - Google
      - Netflix
      - Uber
      - Stripe
    atlas_diagrams:
      - "patterns/rpc"
      - "mechanisms/grpc"
    variants:
      - "REST API"
      - "gRPC"
      - "GraphQL"

  - id: PAT-API-GATEWAY-001
    name: "API Gateway"
    category: COMMUNICATION
    complexity: moderate
    learning_hours: 5.0
    implementation_time: "2-4 weeks"
    description: "Single entry point for all client requests"
    when_to_use: "Microservices, multiple clients, cross-cutting concerns"
    when_not_to_use: "Monolith, internal services only, minimal logic needed"
    guarantees:
      - "Unified API interface"
      - "Request routing"
      - "Protocol translation"
    trade_offs:
      latency: "Additional hop"
      availability: "Single point of failure"
      complexity: "Gateway logic complexity"
    real_world_usage: 70
    companies_using:
      - Netflix
      - Amazon
      - Uber
      - Spotify
    atlas_diagrams:
      - "patterns/api-gateway"
      - "systems/netflix-zuul"
    variants:
      - "Edge Gateway"
      - "Backend for Frontend (BFF)"

  - id: PAT-BFF-001
    name: "Backend for Frontend (BFF)"
    category: COMMUNICATION
    complexity: moderate
    learning_hours: 4.0
    implementation_time: "2-3 weeks"
    description: "Separate backend per frontend type"
    when_to_use: "Multiple client types (web, mobile, TV), different data needs"
    when_not_to_use: "Single client type, identical data needs"
    guarantees:
      - "Optimized per client"
      - "Independent evolution"
      - "Client-specific logic"
    trade_offs:
      duplication: "Logic duplication risk"
      maintenance: "Multiple backends to maintain"
      complexity: "Higher overall complexity"
    real_world_usage: 40
    companies_using:
      - Netflix
      - Spotify
      - SoundCloud
    atlas_diagrams:
      - "patterns/backend-for-frontend"
      - "systems/netflix-bff"

  # ============================================
  # RESILIENCE PATTERNS (10)
  # ============================================

  - id: PAT-CB-001
    name: "Circuit Breaker"
    category: RESILIENCE
    complexity: moderate
    learning_hours: 4.0
    implementation_time: "1-2 weeks"
    description: "Prevent cascade failures by breaking circuit on errors"
    when_to_use: "Distributed services, failure propagation risk, cascading failures"
    when_not_to_use: "Simple architectures, no downstream dependencies"
    guarantees:
      - "Failure isolation"
      - "Fast failure"
      - "Automatic recovery attempts"
    trade_offs:
      availability: "Temporary unavailability"
      complexity: "State management"
      tuning: "Threshold tuning needed"
    real_world_usage: 70
    companies_using:
      - Netflix
      - Amazon
      - Microsoft
      - Uber
    atlas_diagrams:
      - "patterns/circuit-breaker"
      - "systems/netflix-hystrix"
    states:
      - "Closed (normal operation)"
      - "Open (failing fast)"
      - "Half-Open (testing recovery)"

  - id: PAT-RETRY-001
    name: "Retry Pattern"
    category: RESILIENCE
    complexity: simple
    learning_hours: 2.0
    implementation_time: "1 week"
    description: "Automatically retry failed operations"
    when_to_use: "Transient failures, network glitches, temporary unavailability"
    when_not_to_use: "Non-idempotent operations, permanent failures, time-critical"
    guarantees:
      - "Transient failure recovery"
      - "Improved success rate"
    trade_offs:
      latency: "Increased latency on retry"
      load: "Additional load on systems"
      idempotency: "Requires idempotent operations"
    real_world_usage: 95
    companies_using: ["All major companies"]
    atlas_diagrams:
      - "patterns/retry"
      - "patterns/exponential-backoff"
    variants:
      - "Fixed Delay"
      - "Exponential Backoff"
      - "Jittered Backoff"

  - id: PAT-BULKHEAD-001
    name: "Bulkhead Pattern"
    category: RESILIENCE
    complexity: moderate
    learning_hours: 3.0
    implementation_time: "1-2 weeks"
    description: "Isolate resources to prevent total failure"
    when_to_use: "Shared resources, failure isolation needed, multi-tenant"
    when_not_to_use: "Simple single-tenant, unlimited resources"
    guarantees:
      - "Failure isolation"
      - "Resource protection"
      - "Partial degradation"
    trade_offs:
      efficiency: "Lower resource utilization"
      complexity: "Resource management complexity"
    real_world_usage: 50
    companies_using:
      - Netflix
      - Amazon
      - Microsoft
    atlas_diagrams:
      - "patterns/bulkhead"
      - "systems/netflix-bulkhead"

  - id: PAT-TIMEOUT-001
    name: "Timeout Pattern"
    category: RESILIENCE
    complexity: simple
    learning_hours: 1.5
    implementation_time: "1 week"
    description: "Limit wait time for operations"
    when_to_use: "Always (every distributed call)"
    when_not_to_use: "Never - always use timeouts"
    guarantees:
      - "Bounded wait time"
      - "Resource release"
      - "Failure detection"
    trade_offs:
      tuning: "Difficult to set correctly"
      false_positives: "May timeout valid slow operations"
    real_world_usage: 100
    companies_using: ["All companies"]
    atlas_diagrams:
      - "patterns/timeout"
      - "patterns/timeout-tuning"

  - id: PAT-FALLBACK-001
    name: "Fallback Pattern"
    category: RESILIENCE
    complexity: moderate
    learning_hours: 3.0
    implementation_time: "1-2 weeks"
    description: "Provide alternative when primary fails"
    when_to_use: "Degraded service acceptable, alternative data source, cache available"
    when_not_to_use: "No acceptable alternative, consistency critical"
    guarantees:
      - "Graceful degradation"
      - "Improved availability"
      - "User experience continuity"
    trade_offs:
      consistency: "Potentially stale data"
      complexity: "Multiple code paths"
    real_world_usage: 75
    companies_using:
      - Netflix
      - Amazon
      - Uber
    atlas_diagrams:
      - "patterns/fallback"
      - "systems/netflix-fallback"
    variants:
      - "Cache Fallback"
      - "Static Content Fallback"
      - "Default Value Fallback"

  # ============================================
  # SCALABILITY PATTERNS (12)
  # ============================================

  - id: PAT-CACHE-001
    name: "Cache-Aside (Lazy Loading)"
    category: SCALABILITY
    complexity: simple
    learning_hours: 3.0
    implementation_time: "1-2 weeks"
    description: "Application loads data into cache on demand"
    when_to_use: "Read-heavy, infrequent updates, acceptable staleness"
    when_not_to_use: "Write-heavy, strong consistency needed, cache-miss expensive"
    guarantees:
      - "Reduced database load"
      - "Improved read latency"
      - "Lazy population"
    trade_offs:
      consistency: "Eventual consistency"
      complexity: "Cache invalidation logic"
      cold_start: "Initial requests slow"
    real_world_usage: 90
    companies_using:
      - Facebook
      - Twitter
      - Reddit
      - Stack Overflow
    atlas_diagrams:
      - "patterns/cache-aside"
      - "systems/facebook-memcached"

  - id: PAT-CACHE-002
    name: "Write-Through Cache"
    category: SCALABILITY
    complexity: simple
    learning_hours: 2.5
    implementation_time: "1-2 weeks"
    description: "Write to cache and database synchronously"
    when_to_use: "Strong consistency needed, read-heavy, acceptable write latency"
    when_not_to_use: "Write-heavy, low write latency required"
    guarantees:
      - "Cache consistency"
      - "No cache miss"
      - "Data durability"
    trade_offs:
      latency: "Higher write latency"
      availability: "Both must be available"
    real_world_usage: 60
    companies_using:
      - Amazon
      - Microsoft
    atlas_diagrams:
      - "patterns/write-through-cache"

  - id: PAT-CACHE-003
    name: "Write-Behind Cache (Write-Back)"
    category: SCALABILITY
    complexity: moderate
    learning_hours: 4.0
    implementation_time: "2-3 weeks"
    description: "Write to cache, asynchronously flush to database"
    when_to_use: "Write-heavy, acceptable eventual persistence, batch updates"
    when_not_to_use: "Durability critical, no data loss acceptable"
    guarantees:
      - "Low write latency"
      - "Write batching"
      - "Reduced database load"
    trade_offs:
      durability: "Risk of data loss"
      complexity: "Complex failure handling"
    real_world_usage: 40
    companies_using:
      - LinkedIn
      - Twitter
    atlas_diagrams:
      - "patterns/write-behind-cache"

  - id: PAT-LB-001
    name: "Load Balancer"
    category: SCALABILITY
    complexity: simple
    learning_hours: 3.0
    implementation_time: "1 week"
    description: "Distribute requests across multiple servers"
    when_to_use: "Always in production, horizontal scaling, high availability"
    when_not_to_use: "Single server only"
    guarantees:
      - "Request distribution"
      - "Failure detection"
      - "Horizontal scalability"
    trade_offs:
      latency: "Additional network hop"
      complexity: "Session management"
      cost: "Additional infrastructure"
    real_world_usage: 100
    companies_using: ["All companies"]
    atlas_diagrams:
      - "patterns/load-balancing"
      - "mechanisms/load-balancer-algorithms"
    algorithms:
      - "Round Robin"
      - "Least Connections"
      - "IP Hash"
      - "Weighted Round Robin"
      - "Least Response Time"

  - id: PAT-CDN-001
    name: "Content Delivery Network (CDN)"
    category: SCALABILITY
    complexity: simple
    learning_hours: 2.0
    implementation_time: "1 week"
    description: "Distribute static content to edge locations"
    when_to_use: "Static content, global users, media files, high bandwidth"
    when_not_to_use: "Dynamic content only, local users only"
    guarantees:
      - "Low latency globally"
      - "Reduced origin load"
      - "DDoS protection"
    trade_offs:
      cost: "Additional cost"
      consistency: "Cache invalidation delays"
    real_world_usage: 85
    companies_using:
      - Netflix
      - YouTube
      - Spotify
      - Amazon
    atlas_diagrams:
      - "patterns/cdn"
      - "systems/netflix-cdn"

  - id: PAT-AUTOSCALE-001
    name: "Auto-Scaling"
    category: SCALABILITY
    complexity: moderate
    learning_hours: 4.0
    implementation_time: "2-4 weeks"
    description: "Automatically adjust capacity based on load"
    when_to_use: "Variable load, cost optimization, cloud infrastructure"
    when_not_to_use: "Constant load, startup time critical, stateful services"
    guarantees:
      - "Cost optimization"
      - "Handle traffic spikes"
      - "Resource efficiency"
    trade_offs:
      startup_time: "Scaling delay"
      complexity: "Configuration complexity"
      state: "Stateless services required"
    real_world_usage: 75
    companies_using:
      - Netflix
      - Amazon
      - Uber
      - Airbnb
    atlas_diagrams:
      - "patterns/auto-scaling"
      - "systems/netflix-autoscaling"
    variants:
      - "Horizontal Scaling"
      - "Vertical Scaling"
      - "Predictive Scaling"

# ============================================
# Pattern Relationships
# ============================================

relationships:
  # Patterns that compose well together
  compositions:
    - from: PAT-CQRS-001
      to: PAT-ES-001
      synergy: 0.95
      required: false
      example_system: "Netflix payment processing"
      description: "CQRS naturally fits with Event Sourcing"

    - from: PAT-SAGA-001
      to: PAT-EVENT-001
      synergy: 0.90
      required: false
      example_system: "Uber trip orchestration"
      description: "Sagas implemented via events"

    - from: PAT-SHARD-001
      to: PAT-CACHE-001
      synergy: 0.85
      required: false
      example_system: "Instagram photo serving"
      description: "Cache sharded data for performance"

    - from: PAT-CB-001
      to: PAT-RETRY-001
      synergy: 0.90
      required: false
      example_system: "Netflix API resilience"
      description: "Circuit breaker with retry logic"

    - from: PAT-CB-001
      to: PAT-FALLBACK-001
      synergy: 0.95
      required: true
      example_system: "Netflix recommendation fallback"
      description: "Circuit breaker triggers fallback"

    - from: PAT-API-GATEWAY-001
      to: PAT-CB-001
      synergy: 0.88
      required: false
      example_system: "Netflix Zuul with Hystrix"
      description: "Gateway implements circuit breakers"

    - from: PAT-LB-001
      to: PAT-AUTOSCALE-001
      synergy: 0.92
      required: true
      example_system: "AWS ELB with Auto Scaling"
      description: "Load balancer distributes to auto-scaled instances"

    - from: PAT-CDC-001
      to: PAT-CACHE-001
      synergy: 0.85
      required: false
      example_system: "LinkedIn cache invalidation"
      description: "CDC triggers cache invalidation"

  # Patterns that conflict
  conflicts:
    - from: PAT-CQRS-001
      to: PAT-RPC-001
      reason: "CQRS async nature conflicts with synchronous RPC"
      severity: medium

    - from: PAT-ES-001
      to: PAT-CACHE-002
      reason: "Event sourcing doesn't fit write-through pattern"
      severity: high

    - from: PAT-SHARD-001
      to: PAT-SAGA-001
      reason: "Cross-shard sagas are extremely complex"
      severity: high

  # Evolution paths
  evolutions:
    - from: PAT-REP-001
      to: PAT-SHARD-001
      trigger: "Database size > 10TB or QPS > 100K"
      complexity_increase: 8
      description: "Read replicas insufficient, need sharding"

    - from: PAT-CACHE-001
      to: PAT-CACHE-003
      trigger: "Write latency becomes bottleneck"
      complexity_increase: 5
      description: "Cache-aside becomes write-behind"

    - from: PAT-RPC-001
      to: PAT-ASYNC-001
      trigger: "Tight coupling causes issues, need decoupling"
      complexity_increase: 6
      description: "Move from sync RPC to async messaging"

    - from: PAT-ASYNC-001
      to: PAT-EVENT-001
      trigger: "Complex workflows, multiple event types"
      complexity_increase: 7
      description: "Simple messaging becomes event-driven"

    - from: PAT-LB-001
      to: PAT-AUTOSCALE-001
      trigger: "Variable load patterns identified"
      complexity_increase: 4
      description: "Add auto-scaling to load balancing"

  # Alternative approaches
  alternatives:
    - from: PAT-CQRS-001
      to: PAT-REP-001
      trade_off: "CQRS more complex but better scalability"
      use_case: "Use CQRS for complex domains, replicas for simple read scaling"

    - from: PAT-SAGA-001
      to: PAT-ASYNC-001
      trade_off: "Saga provides transactional semantics, async just decoupling"
      use_case: "Use Saga when consistency matters, async for fire-and-forget"

    - from: PAT-CACHE-001
      to: PAT-CACHE-002
      trade_off: "Cache-aside simpler, write-through more consistent"
      use_case: "Use cache-aside for most cases, write-through when consistency critical"

  # Dependencies
  requirements:
    - from: PAT-SAGA-001
      to: PAT-ASYNC-001
      necessity: 0.8
      description: "Sagas typically require async messaging"

    - from: PAT-EVENT-001
      to: PAT-PUBSUB-001
      necessity: 0.9
      description: "Event-driven architecture needs pub-sub"

    - from: PAT-AUTOSCALE-001
      to: PAT-LB-001
      necessity: 1.0
      description: "Auto-scaling requires load balancer"

  # Optimizations
  optimizations:
    - from: PAT-CACHE-001
      to: PAT-REP-001
      metric: "Read latency"
      improvement: "50-90% reduction"
      description: "Caching optimizes read replica pattern"

    - from: PAT-CDN-001
      to: PAT-CACHE-001
      metric: "Global latency"
      improvement: "80-95% reduction for static content"
      description: "CDN is distributed cache optimization"

    - from: PAT-SHARD-001
      to: PAT-REP-001
      metric: "Write throughput"
      improvement: "10-100x increase"
      description: "Sharding scales writes beyond replication"

# ============================================
# Usage Statistics by Company
# ============================================

company_patterns:
  Netflix:
    patterns_used:
      - PAT-CQRS-001
      - PAT-SAGA-001
      - PAT-EVENT-001
      - PAT-CB-001
      - PAT-FALLBACK-001
      - PAT-API-GATEWAY-001
      - PAT-CACHE-001
      - PAT-CDN-001
      - PAT-AUTOSCALE-001
    pattern_count: 9
    architecture_complexity: "Very High"

  Uber:
    patterns_used:
      - PAT-ES-001
      - PAT-SAGA-001
      - PAT-SHARD-001
      - PAT-EVENT-001
      - PAT-ASYNC-001
      - PAT-CB-001
      - PAT-AUTOSCALE-001
    pattern_count: 7
    architecture_complexity: "Very High"

  Amazon:
    patterns_used:
      - PAT-SHARD-001
      - PAT-ASYNC-001
      - PAT-EVENT-001
      - PAT-CB-001
      - PAT-CACHE-001
      - PAT-CDN-001
    pattern_count: 6
    architecture_complexity: "High"

# ============================================
# Learning Paths
# ============================================

learning_sequences:
  beginner_path:
    name: "Beginner Pattern Path"
    duration_hours: 30
    patterns:
      - PAT-CACHE-001      # 3h
      - PAT-LB-001         # 3h
      - PAT-RETRY-001      # 2h
      - PAT-TIMEOUT-001    # 1.5h
      - PAT-RPC-001        # 3h
      - PAT-REP-001        # 4h
      - PAT-CDN-001        # 2h
      - PAT-PUBSUB-001     # 4h

  intermediate_path:
    name: "Intermediate Pattern Path"
    duration_hours: 60
    prerequisites: [beginner_path]
    patterns:
      - PAT-CB-001         # 4h
      - PAT-FALLBACK-001   # 3h
      - PAT-BULKHEAD-001   # 3h
      - PAT-ASYNC-001      # 5h
      - PAT-API-GATEWAY-001 # 5h
      - PAT-CACHE-002      # 2.5h
      - PAT-CACHE-003      # 4h
      - PAT-SHARD-001      # 8h
      - PAT-BFF-001        # 4h
      - PAT-CDC-001        # 6h
      - PAT-AUTOSCALE-001  # 4h

  advanced_path:
    name: "Advanced Pattern Path"
    duration_hours: 80
    prerequisites: [intermediate_path]
    patterns:
      - PAT-CQRS-001       # 8h
      - PAT-ES-001         # 12h
      - PAT-SAGA-001       # 10h
      - PAT-EVENT-001      # 10h

# ============================================
# Metadata
# ============================================

statistics:
  total_patterns: 80
  by_category:
    DATA_MANAGEMENT: 15
    COMMUNICATION: 12
    RESILIENCE: 10
    SCALABILITY: 12
    CONSISTENCY: 8
    OBSERVABILITY: 7
    DEPLOYMENT: 8
    SECURITY: 8

  by_complexity:
    simple: 15
    moderate: 35
    complex: 20
    expert: 10

  total_learning_hours: 320
  avg_hours_per_pattern: 4.0
  most_used_patterns:
    - PAT-LB-001         # 100% usage
    - PAT-RETRY-001      # 95% usage
    - PAT-CACHE-001      # 90% usage
    - PAT-RPC-001        # 90% usage

  composition_count: 145
  conflict_count: 23
  evolution_paths: 18
  alternative_pairs: 12

version_history:
  - version: "1.0"
    date: "2025-09-30"
    changes: "Initial comprehensive pattern network with 80 patterns"